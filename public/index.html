<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>KAPUCHI RACER</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            max-height: 600px;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #0a0a1a;
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(180deg, #0a0a1a 0%, #1a0a2a 50%, #0a1a2a 100%);
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        .title {
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #0ff;
            margin-bottom: 10px;
            letter-spacing: 8px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        .subtitle {
            font-size: clamp(1rem, 4vw, 1.5rem);
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
            margin-bottom: 40px;
            letter-spacing: 4px;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #0ff; }
            to { text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 80px #0ff; }
        }

        .startBtn {
            padding: 20px 60px;
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-family: 'Courier New', monospace;
            font-weight: bold;
            background: transparent;
            border: 3px solid #0ff;
            color: #0ff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 4px;
            transition: all 0.3s;
            margin: 10px;
        }

        .startBtn:hover, .startBtn:active {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff;
        }

        .instructions {
            color: #888;
            font-size: clamp(0.7rem, 2.5vw, 0.9rem);
            margin-top: 30px;
            text-align: center;
            line-height: 1.8;
        }

        .score-display {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            color: #0ff;
            margin: 20px 0;
        }

        #mobileControls {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            padding: 0 20px;
            z-index: 5;
        }

        .controlRow {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .mobileBtn {
            width: 70px;
            height: 70px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #0ff;
            border-radius: 50%;
            color: #0ff;
            font-size: 1.8rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .mobileBtn:active {
            background: rgba(0, 255, 255, 0.5);
        }

        .turboBtn {
            background: rgba(255, 0, 255, 0.2);
            border-color: #f0f;
            color: #f0f;
            position: absolute;
            right: 20px;
            bottom: 100px;
        }

        .turboBtn:active {
            background: rgba(255, 0, 255, 0.5);
        }

        @media (pointer: coarse) {
            #mobileControls {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="startScreen">
            <div class="title">KAPUCHI</div>
            <div class="subtitle">‚ö° R A C E R ‚ö°</div>
            <button class="startBtn" id="startBtn">INICIAR</button>
            <div class="instructions">
                ‚Üê ‚Üí Mover | ESPACIO Turbo<br>
                Esquiva el tr√°fico y llega lo m√°s lejos posible
            </div>
        </div>

        <div id="gameOverScreen" class="hidden">
            <div class="title">GAME OVER</div>
            <div class="score-display">DISTANCIA: <span id="finalScore">0</span> KM</div>
            <div class="score-display" style="color: #f0f;">R√âCORD: <span id="highScore">0</span> KM</div>
            <button class="startBtn" id="restartBtn">REINICIAR</button>
        </div>

        <div id="mobileControls">
            <div class="controlRow">
                <div class="mobileBtn" id="leftBtn">‚óÄ</div>
                <div class="mobileBtn" id="rightBtn">‚ñ∂</div>
            </div>
            <div class="mobileBtn turboBtn" id="turboBtn">üî•</div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Screen elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');

        // Set canvas size
        function resize() {
            const container = document.getElementById('gameContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Game variables
        let gameRunning = false;
        let score = 0;
        let highScore = 0;
        try {
            highScore = parseInt(localStorage.getItem('kapuchiRacerHS')) || 0;
        } catch(e) {}

        let speed = 0;
        let position = 0;
        let playerX = 0;
        let turboActive = false;
        let turboFuel = 100;

        // Road segments
        let segments = [];
        const segmentLength = 200;
        const roadWidth = 2000;
        const rumbleLength = 3;
        const drawDistance = 80;

        // Traffic
        let cars = [];

        // Input state
        const keys = { left: false, right: false, turbo: false };

        // Create road
        function createRoad() {
            segments = [];
            for (let i = 0; i < 500; i++) {
                let curve = 0;
                if (i > 30 && i < 60) curve = 3;
                if (i > 80 && i < 120) curve = -4;
                if (i > 150 && i < 200) curve = Math.sin(i * 0.1) * 5;
                if (i > 250 && i < 350) curve = Math.cos(i * 0.08) * 6;
                if (i > 400) curve = Math.sin(i * 0.05) * 4;
                
                segments.push({
                    index: i,
                    curve: curve,
                    z: i * segmentLength
                });
            }
        }

        // Create traffic
        function createTraffic() {
            cars = [];
            for (let i = 0; i < 15; i++) {
                cars.push({
                    z: 3000 + i * 3000 + Math.random() * 2000,
                    lane: Math.floor(Math.random() * 3) - 1,
                    speed: 80 + Math.random() * 60,
                    color: ['#ff3366', '#33ff66', '#ffaa00', '#ff66ff', '#66ffff'][Math.floor(Math.random() * 5)]
                });
            }
        }

        // Project point to screen
        function project(z, camZ, x, y) {
            const scale = 150 / (z - camZ);
            return {
                x: canvas.width / 2 + scale * x * canvas.width * 0.5,
                y: canvas.height / 2 - scale * y * canvas.height * 0.5,
                w: scale * roadWidth * canvas.width * 0.5,
                scale: scale
            };
        }

        // Draw polygon
        function drawPoly(x1, y1, x2, y2, x3, y3, x4, y4, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.lineTo(x4, y4);
            ctx.closePath();
            ctx.fill();
        }

        // Draw hover wheelchair
        function drawPlayer() {
            const cx = canvas.width / 2 + playerX * canvas.width * 0.25;
            const cy = canvas.height - 100;
            const tilt = playerX * 0.15;
            
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(tilt);
            
            // Turbo flames
            if (turboActive && turboFuel > 0) {
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.moveTo(-10, 35);
                ctx.lineTo(10, 35);
                ctx.lineTo(0, 70 + Math.random() * 15);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.moveTo(-5, 35);
                ctx.lineTo(5, 35);
                ctx.lineTo(0, 55 + Math.random() * 10);
                ctx.closePath();
                ctx.fill();
            }
            
            // Hover glow
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 20;
            ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 40, 35, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Main body
            ctx.fillStyle = '#1a1a2e';
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            
            // Seat back
            ctx.beginPath();
            ctx.rect(-18, -35, 36, 45);
            ctx.fill();
            ctx.stroke();
            
            // Seat
            ctx.fillStyle = '#16213e';
            ctx.beginPath();
            ctx.rect(-22, 10, 44, 18);
            ctx.fill();
            ctx.stroke();
            
            // Armrests
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(-28, 0, 8, 22);
            ctx.fillRect(20, 0, 8, 22);
            ctx.strokeRect(-28, 0, 8, 22);
            ctx.strokeRect(20, 0, 8, 22);
            
            // Hover pods
            ctx.fillStyle = '#0ff';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.ellipse(-22, 32, 10, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(22, 32, 10, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Control panel lights
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(-12, 8, 24, 10);
            ctx.fillStyle = turboActive ? '#f0f' : '#0f0';
            ctx.fillRect(-9, 11, 5, 5);
            ctx.fillStyle = '#ff0';
            ctx.fillRect(-2, 11, 5, 5);
            ctx.fillStyle = '#0ff';
            ctx.fillRect(5, 11, 5, 5);
            
            // Rider head
            ctx.fillStyle = '#0a0a15';
            ctx.beginPath();
            ctx.arc(0, -48, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Visor
            ctx.fillStyle = '#0ff';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.ellipse(0, -46, 9, 5, 0, 0, Math.PI);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.restore();
        }

        // Draw traffic car
        function drawCar(screenX, screenY, scale, color) {
            const w = 35 * scale * 20;
            const h = 50 * scale * 20;
            
            if (w < 2) return;
            
            ctx.save();
            ctx.translate(screenX, screenY);
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(0, h * 0.3, w * 0.7, h * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Body
            ctx.fillStyle = color;
            ctx.fillRect(-w/2, -h/2, w, h);
            
            // Windshield
            ctx.fillStyle = '#113';
            ctx.fillRect(-w/3, -h/3, w * 0.66, h/3);
            
            // Tail lights
            ctx.fillStyle = '#f00';
            ctx.fillRect(-w/2 + 3, h/2 - 8, 6, 5);
            ctx.fillRect(w/2 - 9, h/2 - 8, 6, 5);
            
            ctx.restore();
        }

        // Main render
        function render() {
            const w = canvas.width;
            const h = canvas.height;
            
            // Sky
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.5);
            skyGrad.addColorStop(0, '#05050f');
            skyGrad.addColorStop(0.5, '#150520');
            skyGrad.addColorStop(1, '#201030');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h * 0.5);
            
            // Stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 40; i++) {
                const sx = ((i * 137 + position * 0.002) % w);
                const sy = (i * 73) % (h * 0.4);
                ctx.fillRect(sx, sy, 1.5, 1.5);
            }
            
            // Ground
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, h * 0.5, w, h * 0.5);
            
            // Camera position
            const baseIndex = Math.floor(position / segmentLength) % segments.length;
            const camZ = position;
            
            // Track cumulative curve for offsetting
            let cumCurve = 0;
            let maxY = h;
            
            // Draw road from back to front
            for (let n = drawDistance - 1; n >= 0; n--) {
                const segIdx = (baseIndex + n) % segments.length;
                const seg = segments[segIdx];
                
                const z1 = seg.z - (position % (segments.length * segmentLength));
                const z2 = z1 + segmentLength;
                
                if (z1 <= 0) continue;
                
                // Apply curve offset
                const curveOffset = cumCurve - playerX * roadWidth * 0.5;
                cumCurve += seg.curve * n * 0.5;
                
                const p1 = project(z1, 0, curveOffset, 0);
                const p2 = project(z2, 0, curveOffset + seg.curve * 20, 0);
                
                if (p1.y >= maxY) continue;
                
                const fog = n / drawDistance;
                
                // Grass
                const grassDark = Math.floor(segIdx / rumbleLength) % 2 === 0;
                const gr = grassDark ? 8 : 12;
                const gg = grassDark ? 15 : 22;
                const gb = grassDark ? 8 : 12;
                ctx.fillStyle = `rgb(${gr}, ${gg}, ${gb})`;
                ctx.fillRect(0, p2.y, w, p1.y - p2.y + 1);
                
                // Road
                const roadGray = Math.floor(35 - fog * 20);
                ctx.fillStyle = `rgb(${roadGray}, ${roadGray}, ${roadGray + 10})`;
                drawPoly(
                    p1.x - p1.w, p1.y,
                    p1.x + p1.w, p1.y,
                    p2.x + p2.w, p2.y,
                    p2.x - p2.w, p2.y,
                    ctx.fillStyle
                );
                
                // Rumble strips
                const rumbleOn = Math.floor(segIdx / rumbleLength) % 2 === 0;
                if (rumbleOn) {
                    ctx.fillStyle = `rgba(0, 255, 255, ${0.7 - fog * 0.5})`;
                } else {
                    ctx.fillStyle = `rgba(255, 0, 255, ${0.7 - fog * 0.5})`;
                }
                
                const rw1 = p1.w * 0.08;
                const rw2 = p2.w * 0.08;
                
                // Left rumble
                drawPoly(
                    p1.x - p1.w - rw1, p1.y,
                    p1.x - p1.w, p1.y,
                    p2.x - p2.w, p2.y,
                    p2.x - p2.w - rw2, p2.y,
                    ctx.fillStyle
                );
                
                // Right rumble
                drawPoly(
                    p1.x + p1.w, p1.y,
                    p1.x + p1.w + rw1, p1.y,
                    p2.x + p2.w + rw2, p2.y,
                    p2.x + p2.w, p2.y,
                    ctx.fillStyle
                );
                
                // Lane markers
                if (Math.floor(segIdx / 4) % 2 === 0) {
                    ctx.fillStyle = `rgba(0, 255, 255, ${0.6 - fog * 0.4})`;
                    const lw1 = p1.w * 0.015;
                    const lw2 = p2.w * 0.015;
                    
                    for (let lane = -1; lane <= 1; lane++) {
                        const lx1 = p1.x + lane * p1.w * 0.33;
                        const lx2 = p2.x + lane * p2.w * 0.33;
                        drawPoly(
                            lx1 - lw1, p1.y,
                            lx1 + lw1, p1.y,
                            lx2 + lw2, p2.y,
                            lx2 - lw2, p2.y,
                            ctx.fillStyle
                        );
                    }
                }
                
                maxY = p2.y;
            }
            
            // Draw cars
            cars.forEach(car => {
                const relZ = car.z - position;
                if (relZ > 100 && relZ < drawDistance * segmentLength * 0.7) {
                    const segIdx = Math.floor(car.z / segmentLength) % segments.length;
                    
                    // Calculate curve offset for this car
                    let carCurve = 0;
                    const carN = Math.floor(relZ / segmentLength);
                    for (let i = 0; i < carN; i++) {
                        const idx = (baseIndex + i) % segments.length;
                        carCurve += segments[idx].curve * i * 0.5;
                    }
                    
                    const carWorldX = car.lane * roadWidth * 0.3 + carCurve - playerX * roadWidth * 0.5;
                    const p = project(relZ, 0, carWorldX, 0);
                    
                    if (p.scale > 0) {
                        drawCar(p.x, p.y - 20 * p.scale * 20, p.scale, car.color);
                    }
                }
            });
            
            // Draw player
            drawPlayer();
            
            // HUD
            ctx.fillStyle = '#0ff';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 8;
            ctx.font = 'bold 22px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(Math.floor(speed) + ' KM/H', 15, 35);
            
            ctx.fillStyle = '#f0f';
            ctx.shadowColor = '#f0f';
            ctx.fillText(Math.floor(score) + ' KM', 15, 62);
            ctx.shadowBlur = 0;
            
            // Turbo bar
            ctx.fillStyle = '#222';
            ctx.fillRect(w - 115, 15, 100, 18);
            ctx.fillStyle = turboFuel > 25 ? '#f0f' : '#ff3333';
            ctx.fillRect(w - 115, 15, turboFuel, 18);
            ctx.strokeStyle = '#f0f';
            ctx.lineWidth = 2;
            ctx.strokeRect(w - 115, 15, 100, 18);
            ctx.fillStyle = '#fff';
            ctx.font = '11px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('TURBO', w - 65, 28);
            
            // Logo
            ctx.fillStyle = '#0ff';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 5;
            ctx.font = 'bold 14px Courier New';
            ctx.fillText('KAPUCHI RACER', w / 2, 25);
            ctx.shadowBlur = 0;
        }

        // Update game
        function update(dt) {
            // Speed
            const maxSpd = turboActive && turboFuel > 0 ? 280 : 180;
            speed += (maxSpd - speed) * 0.03;
            
            // Turbo fuel
            if (turboActive && turboFuel > 0) {
                turboFuel -= dt * 35;
            } else if (!turboActive && turboFuel < 100) {
                turboFuel += dt * 12;
            }
            turboFuel = Math.max(0, Math.min(100, turboFuel));
            
            // Position
            position += speed * dt * 40;
            
            // Score
            score += speed * dt * 0.008;
            
            // Player movement
            if (keys.left) playerX -= dt * 2.5;
            if (keys.right) playerX += dt * 2.5;
            playerX = Math.max(-1.1, Math.min(1.1, playerX));
            
            // Apply curve
            const baseIdx = Math.floor(position / segmentLength) % segments.length;
            const curve = segments[baseIdx].curve;
            playerX += curve * speed * 0.000008;
            
            // Update cars
            cars.forEach(car => {
                car.z -= (speed - car.speed) * dt * 40;
                
                if (car.z < position - 500) {
                    car.z = position + 25000 + Math.random() * 15000;
                    car.lane = Math.floor(Math.random() * 3) - 1;
                }
                
                // Collision
                const relZ = car.z - position;
                if (relZ > 0 && relZ < 250) {
                    const carX = car.lane * 0.33;
                    if (Math.abs(carX - playerX) < 0.35) {
                        gameOver();
                    }
                }
            });
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            const finalScore = Math.floor(score);
            if (finalScore > highScore) {
                highScore = finalScore;
                try {
                    localStorage.setItem('kapuchiRacerHS', highScore);
                } catch(e) {}
            }
            document.getElementById('finalScore').textContent = finalScore;
            document.getElementById('highScore').textContent = highScore;
            gameOverScreen.classList.remove('hidden');
        }

        // Start game
        function startGame() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            
            score = 0;
            speed = 0;
            position = 0;
            playerX = 0;
            turboFuel = 100;
            turboActive = false;
            
            createRoad();
            createTraffic();
            
            gameRunning = true;
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // Game loop
        let lastTime = 0;
        function gameLoop(time) {
            if (!gameRunning) return;
            
            const dt = Math.min((time - lastTime) / 1000, 0.05);
            lastTime = time;
            
            update(dt);
            render();
            
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);

        // Keyboard
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
            if (e.key === ' ') { turboActive = true; e.preventDefault(); }
        });
        
        document.addEventListener('keyup', function(e) {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
            if (e.key === ' ') turboActive = false;
        });

        // Mobile
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const turboBtn = document.getElementById('turboBtn');

        leftBtn.addEventListener('touchstart', function(e) { e.preventDefault(); keys.left = true; });
        leftBtn.addEventListener('touchend', function(e) { e.preventDefault(); keys.left = false; });
        rightBtn.addEventListener('touchstart', function(e) { e.preventDefault(); keys.right = true; });
        rightBtn.addEventListener('touchend', function(e) { e.preventDefault(); keys.right = false; });
        turboBtn.addEventListener('touchstart', function(e) { e.preventDefault(); turboActive = true; });
        turboBtn.addEventListener('touchend', function(e) { e.preventDefault(); turboActive = false; });

        // Prevent scroll
        document.body.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
    </script>
</body>
</html>
